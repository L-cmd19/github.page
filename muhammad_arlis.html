<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Muhammad Arlis</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background: #fff;
    }
    header {
      background: #222;
      color: white;
      padding: 40px 0;
      text-align: center;
    }
    header h1 {
      margin: 0;
      border-bottom: 3px solid red;
      display: inline-block;
      padding-bottom: 10px;
    }
    section {
      padding: 30px 20px;
    }
    .welcome {
      text-align: center;
      font-weight: bold;
      font-size: 20px;
      margin-bottom: 40px;
    }
    .card {
      display: flex;
      align-items: flex-start;
      gap: 20px;
      margin-bottom: 40px;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }
    .card img {
      width: 150px;
      height: auto;
    }
    .card-content {
      flex: 1;
    }
    .card-content h2 {
      margin: 0;
      font-size: 20px;
      color: #222;
    }
    .card-content p {
      font-size: 14px;
      color: #444;
    }
    footer {
      background: #d43c3c;
      color: white;
      text-align: center;
      padding: 20px 0;
      font-weight: bold;
    }
  </style>
</head>
<body>

<header>
  <h1>MUHAMMAD ARLIS</h1>
</header>

<section>
  <div class="welcome">SELAMAT DATANG</div>

  <div class="card">
    <img src="activity_selection.png" alt="Activity Selection">
    <div class="card-content">
      <h2>ACTIVITY SELECTION PROBLEM</h2>
      <p>Permasalahan Activity Selection Problem berfokus pada pemilihan sejumlah aktivitas dari sekumpulan aktivitas yang memiliki waktu mulai dan selesai, sehingga tidak ada dua aktivitas yang tumpang tindih dan jumlah aktivitas yang terpilih menjadi maksimum. Ini adalah masalah optimasi klasik yang sering diselesaikan menggunakan pendekatan greedy. Algoritma greedy bekerja dengan selalu memilih aktivitas yang selesai paling awal, asalkan tidak bertabrakan dengan aktivitas yang sudah terpilih.
</p>
    </div>
  </div>

  <div class="card">
    <img src="fractional_knapsack.png" alt="Fractional Knapsack">
    <div class="card-content">
      <h2>FRACTIONAL KNAPSACK</h2>
      <p>Fractional Knapsack adalah masalah optimasi di mana tujuannya adalah untuk mengisi "ransel" dengan sejumlah material yang dapat dibagi (pecahan), sehingga total nilai material yang dipilih menjadi maksimum tanpa melebihi kapasitas berat ransel. Berbeda dengan 0/1 Knapsack di mana item harus diambil secara utuh atau tidak sama sekali, dalam Fractional Knapsack kita bisa mengambil sebagian dari sebuah item. Masalah ini dapat dipecahkan secara efisien menggunakan algoritma greedy, di mana kita mengurutkan item berdasarkan rasio nilai per unit berat (Vi​/Wi​) secara menurun dan mengambil item dengan rasio tertinggi terlebih dahulu hingga ransel penuh, bahkan jika itu berarti mengambil sebagian dari item terakhir. 
.</p>
    </div>
  </div>

  <div class="card">
    <img src="huffman_coding.png" alt="Huffman Coding">
    <div class="card-content">
      <h2>HUFFMAN CODING</h2>
      <p>Huffman Coding adalah algoritma kompresi data lossless yang sangat efisien, dirancang oleh David Huffman pada tahun 1952. Prinsip utamanya adalah menetapkan kode biner dengan panjang variabel untuk setiap karakter dalam data, di mana karakter yang lebih sering muncul akan mendapatkan kode yang lebih pendek, sementara karakter yang jarang muncul mendapatkan kode yang lebih panjang. Ini dilakukan dengan membangun pohon biner khusus (disebut Huffman Tree) berdasarkan frekuensi kemunculan setiap karakter. 
</p>
    </div>
  </div>

  <div class="card">
    <img src="n_queens.png" alt="N-Queens Problem">
    <div class="card-content">
      <h2>N-QUEENS PROBLEM</h2>
      <p>N-Queens Problem adalah sebuah teka-teki klasik dalam dunia komputasi di mana kita harus menempatkan N ratu catur di papan berukuran N×N sedemikian rupa sehingga tidak ada satu pun ratu yang saling menyerang—artinya, tidak ada dua ratu yang berbagi baris, kolom, atau diagonal yang sama. Umumnya, masalah ini diselesaikan menggunakan pendekatan backtracking, sebuah metode rekursif yang secara sistematis mencoba setiap kemungkinan posisi untuk ratu, dan jika penempatan ratu di suatu posisi tidak aman, algoritma akan "mundur" untuk mencoba alternatif lain hingga semua ratu berhasil ditempatkan atau semua kombinasi telah dieksplorasi. 
</p>
    </div>
  </div>

  <div class="card">
    <img src="subset_sum.png" alt="Subset Sum Problem">
    <div class="card-content">
      <h2>SUBSET SUM PROBLEM</h2>
      <p>Subset Sum Problem adalah masalah klasik dalam ilmu komputer yang menanyakan apakah ada subset dari sekumpulan bilangan bulat yang diberikan yang jumlahnya (sum) sama dengan nilai target tertentu. Ini adalah contoh masalah keputusan NP-lengkap, yang berarti tidak ada algoritma waktu polinomial yang diketahui untuk menyelesaikannya secara umum. Meskipun demikian, untuk input dengan ukuran tertentu, masalah ini dapat dipecahkan secara efisien menggunakan pendekatan dynamic programming. Solusi dynamic programming biasanya membangun tabel kebenaran untuk menentukan apakah setiap kemungkinan jumlah hingga target dapat dibentuk menggunakan elemen-elemen dari himpunan, mempertimbangkan setiap elemen satu per satu. 
</p>
    </div>
  </div>

  <div class="card">
    <img src="rat_in_maze.png" alt="Rat in a Maze">
    <div class="card-content">
      <h2>RAT IN A MAZE</h2>
      <p>Rat in a Maze adalah masalah algoritmik klasik di mana seekor tikus ditempatkan di sel awal (biasanya kiri atas) dari sebuah labirin berbentuk grid 2D dan harus menemukan jalur ke sel tujuan (biasanya kanan bawah). Labirin terdiri dari sel-sel yang dapat dilalui (ditandai dengan '1') dan sel-sel yang diblokir atau dinding (ditandai dengan '0'). Tikus dapat bergerak ke atas, bawah, kiri, atau kanan (tergantung variasi masalahnya). Masalah ini adalah contoh sempurna untuk mengilustrasikan algoritma backtracking. Solusi backtracking secara rekursif menjelajahi semua kemungkinan jalur dari titik awal, menandai sel yang dikunjungi untuk menghindari perulangan, dan jika jalur menemui jalan buntu, algoritma akan "mundur" ke sel sebelumnya untuk mencoba arah yang berbeda hingga menemukan jalur ke tujuan atau menentukan bahwa tidak ada jalur yang memungkinkan. 
</p>
    </div>
  </div>

  <div class="card">
    <img src="bfs.png" alt="Breadth First Search">
    <div class="card-content">
      <h2>BREADTH-FIRST SEARCH (BFS)</h2>
      <p>Breadth-First Search (BFS) adalah algoritma penelusuran atau penjelajahan graf yang secara sistematis menjelajahi semua simpul dalam graf secara level demi level atau lapisan demi lapisan. Dimulai dari simpul awal, BFS pertama-tama mengunjungi semua tetangga langsung dari simpul tersebut, kemudian mengunjungi semua tetangga dari tetangga tersebut, dan seterusnya. BFS menggunakan antrean (queue) untuk menyimpan simpul-simpul yang akan dikunjungi, memastikan bahwa simpul-simpul yang "lebih dekat" ke simpul awal akan dikunjungi terlebih dahulu. Algoritma ini sering digunakan untuk menemukan jalur terpendek dalam graf yang tidak berbobot (unweighted graph), mengidentifikasi komponen terhubung, dan dalam berbagai aplikasi lain seperti web crawling dan sistem rekomendasi. 
</p>
    </div>
  </div>

  <div class="card">
    <img src="dfs.png" alt="Depth First Search">
    <div class="card-content">
      <h2>DEPTH-FIRST SEARCH (DFS)</h2>
      <p>Depth-First Search (DFS) adalah algoritma penelusuran graf atau pohon yang bekerja dengan menjelajahi sejauh mungkin setiap "cabang" sebelum melakukan backtracking. Dimulai dari simpul awal, DFS akan bergerak "dalam" ke salah satu tetangga, lalu ke tetangga dari tetangga tersebut, dan seterusnya, sampai mencapai simpul yang tidak memiliki tetangga yang belum dikunjungi. Pada titik ini, algoritma akan "mundur" (backtrack) ke simpul sebelumnya untuk mencoba jalur atau cabang lain yang belum dijelajahi. DFS secara alami dapat diimplementasikan secara rekursif atau menggunakan struktur data tumpukan (stack) untuk melacak simpul-simpul yang perlu dikunjungi. Algoritma ini sering digunakan untuk mendeteksi siklus dalam graf, menemukan komponen terhubung, dan dalam masalah pencarian jalur seperti menyelesaikan labirin 
.</p>
    </div>
  </div>

  <div class="card">
    <img src="kahns_algorithm.png" alt="Kahn's Algorithm">
    <div class="card-content">
      <h2>KAHN’S ALGORITHM</h2>
      <p>Kahn's Algorithm adalah sebuah algoritma yang digunakan untuk melakukan topological sorting pada sebuah Directed Acyclic Graph (DAG), yaitu mengurutkan simpul-simpul graf secara linear sehingga untuk setiap panah langsung dari simpul u ke simpul v, simpul u selalu muncul sebelum simpul v dalam urutan. Algoritma ini bekerja dengan pendekatan berbasis in-degree, di mana ia pertama-tama menghitung jumlah in-degree (jumlah panah yang masuk) untuk setiap simpul. Kemudian, semua simpul yang memiliki in-degree 0 (tidak ada ketergantungan) dimasukkan ke dalam antrean. Secara iteratif, algoritma akan mengeluarkan simpul dari antrean, menambahkannya ke daftar hasil urutan topologi, dan mengurangi in-degree dari semua tetangga simpul yang baru saja dikeluarkan. Jika in-degree dari tetangga mana pun menjadi 0, tetangga tersebut akan ditambahkan ke antrean. Proses ini berlanjut hingga antrean kosong; jika semua simpul berhasil ditambahkan ke urutan, maka graf tersebut adalah DAG dan urutan topologinya telah ditemukan. Jika ada simpul yang tersisa dan antrean kosong, itu berarti graf memiliki siklus.</p>
    </div>
  </div>

  <div class="card">
    <img src="dijkstra.png" alt="Dijkstra's Algorithm">
    <div class="card-content">
      <h2>DIJKSTRA’S ALGORITHM</h2>
      <p>Dijkstra's Algorithm adalah algoritma greedy yang digunakan untuk menemukan jalur terpendek dari satu simpul sumber ke semua simpul lainnya dalam sebuah graf berbobot, dengan syarat semua bobot sisi (edge weights) adalah non-negatif. Algoritma ini bekerja dengan membangun "pohon jalur terpendek" dari simpul sumber, secara bertahap memperluasnya ke simpul-simpul yang belum dikunjungi. Pada setiap langkah, ia memilih simpul yang belum dikunjungi dengan jarak terpendek dari simpul sumber yang diketahui sejauh ini, lalu memperbarui jarak ke tetangga-tetangganya jika ditemukan jalur yang lebih pendek melalui simpul yang baru dipilih. Untuk efisiensi, algoritma ini umumnya menggunakan priority queue (antrean prioritas) untuk menyimpan simpul-simpul yang akan diproses, memastikan bahwa simpul dengan jarak terpendek selalu diambil lebih dulu. 
</p>
    </div>
  </div>

</section>

<footer>
  TERIMAKASIH
</footer>

</body>
</html>
